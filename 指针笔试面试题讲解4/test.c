#include <stdio.h>

//// 笔试题6
//int main()
//{
//	int arr[10] = { 1,2,3,4,5 };
//	int* p = arr; //arr首元素地址
//	// *(p + 2) == p[2] == *(arr + 2) == arr[2] == 3;
//	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
//	// 1 2 3 4 5 // 6 7 8 9 10
//	int* ptr1 = (int*)(&aa + 1);
//	//&aa这里取出整个二维数组的地址，加1跳过整个数组 - 数组指针（才能存放数组的地址）加1还是数组指针
//	//（int*）将数组指针强制转换成整形指针，和ptr1类型相同，指向位置不变，ptr1 -> 10末尾
//	int* ptr2 = (int*)(*(aa + 1));
//	//这里的aa是首元素地址，二维数组的首元素应该是它的第一行，aa+1跳过一行，指向6末尾
//	//所以*(aa+1)相当于得到了第二行，又因为 *(aa+1) = aa[1],即第二行的数组名，
//	//在这里又指第二行首元素的地址,即6的地址，这里的(int*)也是强制类型转化，但在这里实际上没有用
//	//他本身就是int*型的， ptr2 -> 6开头
//	printf("%d,%d\n", *(ptr1 - 1), *(ptr2 - 1));
//	//ptr1是整形，减1就是向前移动一个整形，挪动到9末尾    
//	//ptr2也是整形，减1也是向前移动一个整形，就挪动到5开头
//	//结果 10,5
//	return 0;
//}

////笔试题7
//////例：
////int main()
////{
////	char* p = "abcdef";
////	//这里指把这个常量字符串的首字符"a"放在p里面去
////	return 0;
////	return 0;
////}
//int main()
//{
//	char* a[] = { "work","at","alibaba" };
//	//a是一个数组，每个元素都是char*,所以里面存的分别是"w"，"a"，"a"的地址
//	char** pa = a;
//	//这里的a表示首元素地址，这里的首元素地址里面存的就是"w"
//	//a元素的类型是char*,所以pa存a的首元素地址(char*类型)，就是char**
//	pa++;
//	//p元素的类型是char*，所以pa++就是跳过一个字符指针(char*)，所以pa就指向a数组的第二个元素
//	//例如：int *p这里的p的每个元素是int型，p+1就跳过一个整形
//	printf("%s\n", *pa);
//	// 这里*pa就是得到了a数组第二个元素的地址，%s是指输出一个字符串，
//	// 所以以第二个元素的地址为开始打印出字符串
//	//结果 at
//	return 0;
//}


//笔试题8

int main()
{
	char* c[] = { "ENTER","NEW","POINT","FIRST" };
	char** cp[] = { c + 3,c + 2,c + 1,c };
	char*** cpp = cp;
	printf("%s\n", **++cpp);
	//cpp原先存的是c+3的地址，++cpp后指向c+2的地址，对(++cpp)解引用就得到c+2的内容,即c中第三个元素的地址
    //再对c+2解引用就得到c中第三个元素的内容，"P",又以%s的方式打印（即以字符串的方式输出） --- POINT
	printf("%s\n", *--*++cpp+3); 
	//先执行++,再是执行*++cpp,再是执行--,再解引用，最后计算+3
	//++cpp它原先已经加1(前一步)，此时它的位置在c+2末尾
	//*++cpp对拿到的(c+1)地址解引用,得到c+1(实际上是得到c+1的空间）
	//--*++cpp就是将得到的c+1内容再减1，就从原先的c+1变成了c，解引用就拿到c数组的第一个元素
	//这个元素的内容又是"ENTER"的第一个字符"E"的地址，
	//然后加3就是在"E"的位置上向后移动3个位置，就指向了"E"的开头，以%s打印                 --- ER
	printf("%s\n", *cpp[-2]+3);
	//*cpp[-2] == **(cpp-2)+3 原先位置不变
	//cpp-2此时指向的是c+3的开头，所以一次解引用得到c数组第四个元素的地址，再对其解引用就得到"F"的地址
	//再在后面+3就是从"F"开始，向后移动3位，再以%s打印                                     --- ST
	printf("%s\n", cpp[-1][-1] + 1);
	//cpp[-1][-1]+1 = *(*(cpp-1)-1)+1  此时cpp的位置还在上一次的位置，c+1的起始处(这种运算不会改变cpp的位置)
	//所以*(cpp-1)得到c+2,c+2减1得c+1,再解引用得c数组的第二个元素，指向"N"的地址，所以加1后移到"E"处
	//再以%s打印                                                                           --- EW
	return 0;
}